"use strict";(self.webpackChunkgreen_software_training=self.webpackChunkgreen_software_training||[]).push([[684],{4137:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),l=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=l(e.components);return a.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=l(t),m=i,g=c["".concat(p,".").concat(m)]||c[m]||d[m]||o;return t?a.createElement(g,r(r({ref:n},u),{},{components:t})):a.createElement(g,r({ref:n},u))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=c;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=t[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},2698:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=t(7462),i=(t(7294),t(4137));const o={sidebar_position:7},r="How to check parameters and units using `explainer`",s={unversionedId:"users/how-to-use-the-explain-feature",id:"users/how-to-use-the-explain-feature",title:"How to check parameters and units using `explainer`",description:"Manifest files can get complicated, especially when there are many plugin instances initialized. It can be challenging to keep track of the flow of parameters and their units through a pipeline. To help manifest authors and auditors verify the correct flow of information through a pipeline, we provide the explainer feature.",source:"@site/docs/users/how-to-use-the-explain-feature.md",sourceDirName:"users",slug:"/users/how-to-use-the-explain-feature",permalink:"/users/how-to-use-the-explain-feature",draft:!1,editUrl:"https://github.com/Green-Software-Foundation/if-docs/edit/master/docs/users/how-to-use-the-explain-feature.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Verifying IF outputs with `if-check`",permalink:"/users/how-to-verify-files-with-if-check"},next:{title:"Developers",permalink:"/developers/"}},p={},l=[{value:"Toggling <code>explainer</code> on or off",id:"toggling-explainer-on-or-off",level:2},{value:"Defining parameter metadata",id:"defining-parameter-metadata",level:2},{value:"Example manifest",id:"example-manifest",level:2},{value:"When <em>not</em> to use <code>explainer</code>",id:"when-not-to-use-explainer",level:2}],u={toc:l};function d(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"how-to-check-parameters-and-units-using-explainer"},"How to check parameters and units using ",(0,i.kt)("inlineCode",{parentName:"h1"},"explainer")),(0,i.kt)("p",null,"Manifest files can get complicated, especially when there are many plugin instances initialized. It can be challenging to keep track of the flow of parameters and their units through a pipeline. To help manifest authors and auditors verify the correct flow of information through a pipeline, we provide the ",(0,i.kt)("inlineCode",{parentName:"p"},"explainer")," feature."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"explainer")," adds a block to the manifest that simply lists metadata for each plugin instance in the manifest. The metadata contains:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"method:")," the function name being executed by the plugin"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"path"),": the import path for the plugin"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"inputs"),": a list of each input parameter"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"outputs"),": a list of each output parameter")),(0,i.kt)("p",null,"Each element in ",(0,i.kt)("inlineCode",{parentName:"p"},"inputs")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"outputs")," contains the following information about each specific parameter:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"description:")," a plain-language summary of the parameter"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"unit:"),": The unit the parameter is expressed in"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"aggregation-method:"),": The appropriate method to use when aggregating the parameter across time or components (e.g. should it be summed, averaged, or held constant)")),(0,i.kt)("p",null,"This information allows you to check that the units output by one plugin are consistent with those expected as inputs to another, in one clear itemized list in your output manifest."),(0,i.kt)("h2",{id:"toggling-explainer-on-or-off"},"Toggling ",(0,i.kt)("inlineCode",{parentName:"h2"},"explainer")," on or off"),(0,i.kt)("p",null,"To enable the ",(0,i.kt)("inlineCode",{parentName:"p"},"explainer")," feature, add the following line to your manifest, somewhere in the manifest context (e.g. above the ",(0,i.kt)("inlineCode",{parentName:"p"},"plugins")," block):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"explainer: true\n")),(0,i.kt)("p",null,"If you set ",(0,i.kt)("inlineCode",{parentName:"p"},"explainer")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," or omit the line altogether, the ",(0,i.kt)("inlineCode",{parentName:"p"},"explainer")," feature will not run."),(0,i.kt)("h2",{id:"defining-parameter-metadata"},"Defining parameter metadata"),(0,i.kt)("p",null,"Plugins are expected to ship with default values for their parameter metadata in their source code. For example, our plugin for calculating embodied carbon, ",(0,i.kt)("inlineCode",{parentName:"p"},"SciEmbodied"),", includes the following metadata definition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-Typescript"},"export const SciEmbodied = (\n  parametersMetadata: PluginParametersMetadata\n): ExecutePlugin => {\n  const metadata = {\n    kind: 'execute',\n    inputs: parametersMetadata?.inputs || {\n      'device/emissions-embodied': {\n        description: 'total embodied emissions of some component',\n        unit: 'gCO2e',\n        aggregationMethod: 'sum',\n      },\n      'device/expected-lifespan': {\n        description: 'Total Expected Lifespan of the Component in Seconds',\n        unit: 'seconds',\n        aggregation-method: 'none',\n      },\n      'resources-reserved': {\n        description: 'resources reserved for an application',\n        unit: 'resources',\n        aggregation-method: 'sum',\n      },\n      'resources-total': {\n        description: 'total resources available',\n        unit: 'resources',\n        aggregation-method: 'sum',\n      },\n      'vcpus-allocated': {\n        description: 'number of vcpus allocated to particular resource',\n        unit: 'vcpus',\n        aggregation-method: 'sum',\n      },\n      'vcpus-total': {\n        description: 'total number of vcpus available on a particular resource',\n        unit: 'vcpus',\n        aggregation-method: 'sum',\n      },\n    },\n    outputs: parametersMetadata?.outputs || {\n      'carbon-embodied': {\n        description: 'embodied emissions of the component',\n        unit: 'gCO2e',\n        aggregation-method: 'sum',\n      },\n    },\n  };\n}\n")),(0,i.kt)("p",null,"However, there are cases where a plugin might not have parameter metadata in its source code, either because it was omitted, it was not knowable in advance, or the plugin was built before we shipped the ",(0,i.kt)("inlineCode",{parentName:"p"},"explain")," feature. Sometimes, you might want to override the hard-coded defaults and use alternative metadata. In these cases, you can define new plugin metadata in the manifest file. It is considered best-practice to ensure all plugin instances have a complete set of plugin metadata."),(0,i.kt)("p",null,"Setting parameter metadata from the manifest file is done in the plugin instance's ",(0,i.kt)("inlineCode",{parentName:"p"},"initialize")," block, as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'initialize:\n  plugins:\n    "interpolate":\n      method: Interpolation\n      path: "builtin"\n      global-config:\n        method: linear\n        x: [0, 10, 50, 100]\n        y: [0.12, 0.32, 0.75, 1.02]\n        input-parameter: "cpu/utilization"\n        output-parameter: "cpu-factor"\n      parameter-metadata:\n        inputs:\n          cpu/utilization:\n            description: "portion of the total CPU capacity being used by an application"\n            unit: "percentage"\n            aggregation-method: "avg"\n        outputs:\n          cpu-factor:\n            description: "a dimensionless intermediate used to scale a processor\'s thermal design power by CPU usage"\n            unit: "dimensionless"\n            aggregation-method: "avg"\n')),(0,i.kt)("h2",{id:"example-manifest"},"Example manifest"),(0,i.kt)("p",null,"The following manifest uses three plugins: ",(0,i.kt)("inlineCode",{parentName:"p"},"sci"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"sci-embodied")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"sum-carbon"),". Of these, only ",(0,i.kt)("inlineCode",{parentName:"p"},"sci-embodied"),' has defaults hardcoded into the plugin code. The other two do not because they are "generic" arithmetic plugins for whom the values cannot be known in advance. Therefore, we set new parameter metadata in the ',(0,i.kt)("inlineCode",{parentName:"p"},"initialize")," block for ",(0,i.kt)("inlineCode",{parentName:"p"},"sci")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"sum-carbon")," but use the hardcoded defaults for ",(0,i.kt)("inlineCode",{parentName:"p"},"sci-embodied"),"."),(0,i.kt)("p",null,"We toggle the ",(0,i.kt)("inlineCode",{parentName:"p"},"explainer")," feature by adding ",(0,i.kt)("inlineCode",{parentName:"p"},"explainer: true")," in the manifest context."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'name: sci\ndescription: successful path\ntags:\nexplainer: true\ninitialize:\n  plugins:\n    sci-embodied:\n      path: "builtin"\n      method: SciEmbodied\n    "sum-carbon":\n      path: "builtin"\n      method: Sum\n      global-config:\n        input-parameters:\n          - carbon-operational\n          - carbon-embodied\n        output-parameter: carbon\n      parameter-metadata:\n        inputs:\n          carbon-operational:\n            description: "carbon emitted due to an application\'s execution"\n            unit: "gCO2eq"\n            aggregation-method: \'sum\',\n          carbon-embodied:\n            description: "carbon emitted during the production, distribution and disposal of a hardware component, scaled by the fraction of the component\'s lifespan being allocated to the application under investigation"\n            unit: "gCO2eq"\n            aggregation-method: \'sum\'\n        outputs:\n          carbon:\n            description: "total carbon emissions attributed to an application\'s usage as the sum of embodied and operational carbon"\n            unit: "gCO2eq"\n            aggregation-method: \'sum\'\n    sci:\n      kind: plugin\n      method: Sci\n      path: "builtin"\n      global-config:\n        functional-unit: requests\n      parameter-metadata:\n        inputs:\n          carbon:\n            description: "total carbon emissions attributed to an application\'s usage as the sum of embodied and operational carbon"\n            unit: "gCO2eq"\n            aggregation-method: \'sum\'\n          requests:\n            description: "number of requests made to application in the given timestep"\n            unit: "requests"\n            aggregation-method: \'sum\'\n        outputs:\n          sci:\n            description: "software carbon intensity expressed as a rate of carbon emission per request"\n            unit: "gCO2eq/request"\n            aggregation-method: \'sum\'\ntree:\n  children:\n    child:\n      pipeline:\n        - sci-embodied\n        - sum-carbon\n        - sci\n      defaults:\n        device/emissions-embodied: 1533.120 # gCO2eq\n        time-reserved: 3600 # 1hr in seconds\n        device/expected-lifespan: 94608000 # 3 years in seconds\n        vcpus-allocated: 1\n        vcpus-total: 8\n      inputs:\n        - timestamp: 2023-07-06T00:00\n          duration: 3600\n          energy: 5\n          carbon-operational: 5\n          requests: 100\n\n')),(0,i.kt)("p",null,"When we execute this manifest, the following ",(0,i.kt)("inlineCode",{parentName:"p"},"explain")," block is added to the output file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"explain:\n  sci-embodied:\n    method: SciEmbodied\n    path: builtin\n    inputs:\n      device/emissions-embodied:\n        description: total embodied emissions of some component\n        unit: gCO2e\n        aggregation-method: 'sum'\n      device/expected-lifespan:\n        description: Total Expected Lifespan of the Component in Seconds\n        unit: seconds\n        aggregation-method: 'none'\n      resources-reserved:\n        description: resources reserved for an application\n        unit: resources\n        aggregation-method: 'sum'\n      resources-total:\n        description: total resources available\n        unit: resources\n        aggregation-method: 'sum'\n      vcpus-allocated:\n        description: number of vcpus allocated to particular resource\n        unit: vcpus\n        aggregation-method: 'sum'\n      vcpus-total:\n        description: total number of vcpus available on a particular resource\n        unit: vcpus\n        aggregation-method: 'sum'\n    outputs:\n      carbon-embodied:\n        description: embodied emissions of the component\n        unit: gCO2e\n        aggregation-method: 'sum'\n  sum-carbon:\n    method: Sum\n    path: builtin\n    inputs:\n      carbon-operational:\n        unit: gCO2eq\n        description: carbon emitted due to an application's execution\n        aggregation-method: 'sum'\n      carbon-embodied:\n        unit: gCO2eq\n        description: >-\n          carbon emitted during the production, distribution and disposal of a\n          hardware component, scaled by the fraction of the component's lifespan\n          being allocated to the application under investigation\n        aggregation-method: 'sum'\n    outputs:\n      carbon:\n        unit: gCO2eq\n        description: >-\n          total carbon emissions attributed to an application's usage as the sum\n          of embodied and operational carbon\n        aggregation-method: 'sum'\n  sci:\n    method: Sci\n    path: builtin\n    inputs:\n      carbon:\n        unit: gCO2eq\n        description: >-\n          total carbon emissions attributed to an application's usage as the sum\n          of embodied and operational carbon\n        aggregation-method: 'sum'\n      requests:\n        unit: requests\n        description: number of requests made to application in the given timestep\n        aggregation-method: 'sum'\n    outputs:\n      sci:\n        unit: gCO2eq/request\n        description: >-\n          software carbon intensity expressed as a rate of carbon emission per\n          request\n        aggregation-method: 'sum'\n")),(0,i.kt)("h2",{id:"when-not-to-use-explainer"},"When ",(0,i.kt)("em",{parentName:"h2"},"not")," to use ",(0,i.kt)("inlineCode",{parentName:"h2"},"explainer")),(0,i.kt)("p",null,"In manifests where you are only using generic plugins, or override all the metadata loaded in from the plugin source code, ",(0,i.kt)("inlineCode",{parentName:"p"},"explainer")," will simply echo back information from your ",(0,i.kt)("inlineCode",{parentName:"p"},"initialize")," block since all the parameter metadata is set there. In these cases, the ",(0,i.kt)("inlineCode",{parentName:"p"},"explain")," block is probably redundant information as you could just read the same information in your manifest's ",(0,i.kt)("inlineCode",{parentName:"p"},"plugins")," section. The point of ",(0,i.kt)("inlineCode",{parentName:"p"},"explain")," is to confirm what units and parameters are being passed through a pipeline when you have a mixture of plugins from many sources whose parameter metadata is defined in-code and in-manifest."))}d.isMDXComponent=!0}}]);