"use strict";(self.webpackChunkgreen_software_training=self.webpackChunkgreen_software_training||[]).push([[875],{4137:(e,t,a)=>{a.d(t,{Zo:()=>l,kt:()=>h});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},l=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),m=c(a),h=o,g=m["".concat(s,".").concat(h)]||m[h]||u[h]||r;return a?n.createElement(g,i(i({ref:t},l),{},{components:a})):n.createElement(g,i({ref:t},l))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=m;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"==typeof e?e:o,i[1]=p;for(var c=2;c<r;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},6076:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>p,toc:()=>c});var n=a(7462),o=(a(7294),a(4137));const r={author:"Asim Hussain (@jawache)",abstract:"An impact graph is the core construct in an Impact Framework through which all the other components interact."},i="Graph",p={unversionedId:"specification/graph",id:"specification/graph",title:"Graph",description:"Introduction",source:"@site/docs/06-specification/graph.md",sourceDirName:"06-specification",slug:"/specification/graph",permalink:"/specification/graph",draft:!1,editUrl:"https://github.com/Green-Software-Foundation/ief/docs/06-specification/graph.md",tags:[],version:"current",frontMatter:{author:"Asim Hussain (@jawache)",abstract:"An impact graph is the core construct in an Impact Framework through which all the other components interact."},sidebar:"tutorialSidebar",previous:{title:"Granularity",permalink:"/specification/granularity"},next:{title:"Impact Engine",permalink:"/specification/impact-engine"}},s={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Structure",id:"structure",level:2},{value:"Component",id:"component",level:3},{value:"Computation",id:"computation",level:3},{value:"Pipeline",id:"pipeline",level:3},{value:"Supporting the 4M&#39;s of Green Software",id:"supporting-the-4ms-of-green-software",level:2},{value:"Evolution",id:"evolution",level:3}],l={toc:c};function u(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"graph"},"Graph"),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"A Graph is part of the manifest file that defines everything you need to calculate the environmental impact of a piece of software. The graph itself it the part of the manifest that comes after the global config. It describes the architecture of the application being studied and contains the inputs for each component."),(0,o.kt)("p",null,"You can describe it in YAML format (",(0,o.kt)("a",{parentName:"p",href:"/specification/manifest-file"},"impl"),") and execute using a command line tool (",(0,o.kt)("a",{parentName:"p",href:"/specification/impact-engine"},"Impact Engine"),") using static input data."),(0,o.kt)("p",null,"The flexibility of impact graphs means they can represent a running software application, a user journey, or a campaign - it should be possible to measure anything with an impact graph. We call the thing a Graph is measuring an ",(0,o.kt)("strong",{parentName:"p"},"Impact Subject"),"."),(0,o.kt)("p",null,"It represents an Ontology of a software system\u2014a graph of all the nested components and sub-components."),(0,o.kt)("p",null,"A Graph is the core of the Impact Framework."),(0,o.kt)("h2",{id:"structure"},"Structure"),(0,o.kt)("p",null,"See the ",(0,o.kt)("a",{parentName:"p",href:"./impl.md"},"Impl")," spec for the latest and complete information regarding the structure of a Graph."),(0,o.kt)("p",null,"In summary, a Graph has a root node containing configuration detailing ",(0,o.kt)("strong",{parentName:"p"},"how")," the graph is computed and a graph node containing details about all the components that make up this impact subject."),(0,o.kt)("p",null,"The graph's leaf nodes (",(0,o.kt)("strong",{parentName:"p"},"Components"),") represent the components that need impacts calculated, e.g. servers, networking, and devices."),(0,o.kt)("p",null,"The intermediate nodes (",(0,o.kt)("strong",{parentName:"p"},"Groupings"),") represent a grouping of leaf nodes for useful aggregation, e.g. ",(0,o.kt)("strong",{parentName:"p"},"backend")," intermediate node might contain all the leaf nodes for the backend components."),(0,o.kt)("p",null,(0,o.kt)("img",{src:a(403).Z,width:"614",height:"569"})),(0,o.kt)("h3",{id:"component"},"Component"),(0,o.kt)("p",null,"Each component has some configuration, some Inputs, and a model."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Configuration")," describes shared information regarding this component and, most importantly, parameters required by this model."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Inputs")," are a time series of data points used as inputs to the model."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Model")," is a plugin ",(0,o.kt)("a",{parentName:"li",href:"/specification/model-plugin"},"Model Plugin")," which when given some configuration and a series of ",(0,o.kt)("a",{parentName:"li",href:"./inputs.md"},"Inputs"),", can calculate the impact, e.g. carbon impact from an input of CPU utilization.")),(0,o.kt)("p",null,(0,o.kt)("img",{src:a(6599).Z,width:"420",height:"316"})),(0,o.kt)("h3",{id:"computation"},"Computation"),(0,o.kt)("p",null,"During graph computation, we first calculate the Component nodes to generate Impact Metrics. Then we aggregate the Impact Metrics up the tree to any Grouping nodes and, finally, a total Impact Metric for the whole graph. Every node in the graph has an impact metric; this means you can analyze a system as a who but also dig into and analyze the impacts of its components."),(0,o.kt)("p",null,(0,o.kt)("img",{src:a(5201).Z,width:"808",height:"566"})),(0,o.kt)("p",null,"A computation of a Graph can create one Impact Metric. It can also be configured to return a ",(0,o.kt)("strong",{parentName:"p"},"time series of outputs"),", so you can identify the moments when impact is higher or lower. Importantly a time series is computed for every node (grouping or component) in the graph so that you can analyze the source of impact structurally and temporally."),(0,o.kt)("h3",{id:"pipeline"},"Pipeline"),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"/specification/computation-pipeline"},"Computation Pipeline")," for details regarding the phases of a Graph Computation. "),(0,o.kt)("p",null,"In summary, there are 4 phases:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Calculation"),": Calculating the outputs of every component leaf node."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Enrichment"),": Enriching the outputs, e.g. calculating the carbon from energy using grid emissions data."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Normalization"),": Bucketing the outputs into a time series of impact durations."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Aggregation"),": Aggregating the outputs by each impact duration, up the graph, to the parent nodes and finally, the root node ")),(0,o.kt)("p",null,"Through the above pipeline process, we can handle multiple types of calculations. To see how we can calculate an SCI score, see [","[Computing SCI Scores]","]."),(0,o.kt)("h2",{id:"supporting-the-4ms-of-green-software"},"Supporting the 4M's of Green Software"),(0,o.kt)("p",null,"We can apply the ",(0,o.kt)("strong",{parentName:"p"},"4Ms")," using a Graph."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Mapping"),": Map clearly what you want to measure, the ",(0,o.kt)("em",{parentName:"li"},"boundary")," of the subject."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Measure"),": Decide the models you want to use to measure the subject's impact."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"siMulate"),": ",(0,o.kt)("em",{parentName:"li"},"Estimate")," the change to the impact metric of making changes to the subject."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Monitor"),": Measure impacts more frequently, so you tighten the feedback loop and iterate faster towards lower impacts.")),(0,o.kt)("p",null,"Creating a graph involves ",(0,o.kt)("strong",{parentName:"p"},"mapping")," a subject you want to measure, simulate and monitor. It could be a software application, a user journey, campaign. Modeling involves adding nodes to the graph, both component and grouping nodes."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Measuring")," involves selecting and configuring the correct measurement plugins for each component in the graph and collecting Inputs to pass to those plugins."),(0,o.kt)("p",null,"Once both steps are complete and you have a baseline, ",(0,o.kt)("em",{parentName:"p"},"computable"),", model of your graph's impacts, you can start ",(0,o.kt)("strong",{parentName:"p"},"simulating")," the effects of making changes. You can change the model to represent a ",(0,o.kt)("em",{parentName:"p"},"what if")," scenario (e.g. changing part of the architecture or runtime of your software), compute the new simulation graph, and see how much this affects the overall impact without making any changes to your software."),(0,o.kt)("p",null,"So far, graph computations are batch processes that start and end with static Inputs embedded. Since the graph represents executable code that takes in some Inputs to generate outputs impacts, it's possible to turn a graph calculation into a continuous process to ",(0,o.kt)("strong",{parentName:"p"},"monitor")," the impacts of your subject. Something that takes a stream of Inputs in and exhausts a stream of output impacts."),(0,o.kt)("h3",{id:"evolution"},"Evolution"),(0,o.kt)("p",null,"One of the most valuable features of a graph is that it can grow and evolve; it can start small and grow in complexity over time. "),(0,o.kt)("p",null,"We need to add ",(0,o.kt)("a",{parentName:"p",href:"/specification/granularity"},"Granularity")," to a graph to get the most out of this process. The more granular a graph is, the more accurate the impacts will be. The more granular a graph, the more opportunities to simulate present themselves. "),(0,o.kt)("p",null,"Most graphs might begin life as ",(0,o.kt)("strong",{parentName:"p"},"one")," component node and ",(0,o.kt)("strong",{parentName:"p"},"one")," Input. This will give you a single impact."),(0,o.kt)("p",null,"Once you desire to see the impacts over time, you might evolve the graph by adding multiple Inputs. "),(0,o.kt)("p",null,"Once you want to see the impacts broken down by sub-components, you evolve the graph by adding more components."),(0,o.kt)("p",null,"The graph can start very simple and grow very complex, but only as complicated as you need to answer your questions and no more."))}u.isMDXComponent=!0},403:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/3f18767c1a55cee416e3de70314609e3-c7fa9feaf0993c3ed2b5a34b8b82432c.png"},5201:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/bcb0066204a750f6b18a43a627c66b90-5fcdd523cc66e42ee447bc2f8323ec24.png"},6599:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/decc58c3420d1e4e3701e5d1ac12883e-f6c0335535f73df7726d9bcd95a3b667.png"}}]);