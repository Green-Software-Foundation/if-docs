"use strict";(self.webpackChunkgreen_software_training=self.webpackChunkgreen_software_training||[]).push([[684],{4137:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>d});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p=a.createContext({}),u=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},l=function(e){var n=u(e.components);return a.createElement(p.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=u(t),d=o,g=m["".concat(p,".").concat(d)]||m[d]||c[d]||i;return t?a.createElement(g,r(r({ref:n},l),{},{components:t})):a.createElement(g,r({ref:n},l))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=m;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var u=2;u<i;u++)r[u]=t[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2698:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=t(7462),o=(t(7294),t(4137));const i={sidebar_position:7},r="How to check parameters and units using `explainer`",s={unversionedId:"users/how-to-use-the-explain-feature",id:"users/how-to-use-the-explain-feature",title:"How to check parameters and units using `explainer`",description:"Manifest files can get complicated, especially when there are many plugin instances initialized. It can be challenging to keep track of the flow of parameters and their units through a pipeline. To help IMP authors and auditors verify the correct flow of information through a pipeline, we provide the explainer feature.",source:"@site/docs/users/how-to-use-the-explain-feature.md",sourceDirName:"users",slug:"/users/how-to-use-the-explain-feature",permalink:"/users/how-to-use-the-explain-feature",draft:!1,editUrl:"https://github.com/Green-Software-Foundation/if-docs/edit/master/docs/users/how-to-use-the-explain-feature.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Verifying IF outputs with `if-check`",permalink:"/users/how-to-verify-files-with-if-check"},next:{title:"Developers",permalink:"/developers/"}},p={},u=[{value:"Toggling <code>explainer</code> on or off",id:"toggling-explainer-on-or-off",level:2},{value:"Defining parameter metadata",id:"defining-parameter-metadata",level:2},{value:"Example IMP",id:"example-imp",level:2},{value:"When <em>not</em> to use <code>explainer</code>",id:"when-not-to-use-explainer",level:2}],l={toc:u};function c(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"how-to-check-parameters-and-units-using-explainer"},"How to check parameters and units using ",(0,o.kt)("inlineCode",{parentName:"h1"},"explainer")),(0,o.kt)("p",null,"Manifest files can get complicated, especially when there are many plugin instances initialized. It can be challenging to keep track of the flow of parameters and their units through a pipeline. To help IMP authors and auditors verify the correct flow of information through a pipeline, we provide the ",(0,o.kt)("inlineCode",{parentName:"p"},"explainer")," feature."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"explainer")," adds a block to the IMP that simply lists the parameter metadata used be the plugin's instance in the IMP. The metadata contains:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"plugins:")," the list of plugins where the parameter is used"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"unit"),": the unit in which the parameter is expressed"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"description:")," a plain-language summary of the parameter"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"aggregation-method:"),": The appropriate method to use when aggregating the parameter across time or components (e.g. should it be summed, averaged, or held constant)")),(0,o.kt)("p",null,"This information allows you to check that the units output by one plugin are consistent with those expected as inputs to another, in one clear itemized list in your output IMP."),(0,o.kt)("p",null,"Note that when the parameter has different units across instances, an error will occur."),(0,o.kt)("h2",{id:"toggling-explainer-on-or-off"},"Toggling ",(0,o.kt)("inlineCode",{parentName:"h2"},"explainer")," on or off"),(0,o.kt)("p",null,"To enable the ",(0,o.kt)("inlineCode",{parentName:"p"},"explainer")," feature, add the following line to your IMP, somewhere in the IMP context (e.g. above the ",(0,o.kt)("inlineCode",{parentName:"p"},"plugins")," block):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"explainer: true\n")),(0,o.kt)("p",null,"If you set ",(0,o.kt)("inlineCode",{parentName:"p"},"explainer")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," or omit the line altogether, the ",(0,o.kt)("inlineCode",{parentName:"p"},"explainer")," feature will not run."),(0,o.kt)("h2",{id:"defining-parameter-metadata"},"Defining parameter metadata"),(0,o.kt)("p",null,"Plugins are expected to ship with default values for their parameter metadata in their source code. For example, our plugin for calculating embodied carbon, ",(0,o.kt)("inlineCode",{parentName:"p"},"SciEmbodied"),", includes the following metadata definition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export const SciEmbodied = PluginFactory({\n  metadata: {\n    inputs: {\n      vCPUs: {\n        description: 'number of CPUs allocated to an application',\n        unit: 'CPUs',\n        'aggregation-method': {\n          time: 'copy',\n          component: 'copy',\n        },\n      },\n      memory: {\n        description: 'RAM available for a resource, in GB',\n        unit: 'GB',\n        'aggregation-method': {\n          time: 'copy',\n          component: 'copy',\n        },\n      },\n      ssd: {\n        description: 'number of SSDs available for a resource',\n        unit: 'SSDs',\n        'aggregation-method': {\n          time: 'copy',\n          component: 'copy',\n        },\n      },\n      hdd: {\n        description: 'number of HDDs available for a resource',\n        unit: 'HDDs',\n        'aggregation-method': {\n          time: 'copy',\n          component: 'copy',\n        },\n      },\n      gpu: {\n        description: 'number of GPUs available for a resource',\n        unit: 'GPUs',\n        'aggregation-method': {\n          time: 'copy',\n          component: 'copy',\n        },\n      },\n      'usage-ratio': {\n        description:\n          'a scaling factor that can be used to describe the ratio of actual resource usage comapred to real device usage, e.g. 0.25 if you are using 2 out of 8 vCPUs, 0.1 if you are responsible for 1 out of 10 GB of storage, etc',\n        unit: 'dimensionless',\n        'aggregation-method': {\n          time: 'copy',\n          component: 'copy',\n        },\n      },\n      time: {\n        description:\n          'a time unit to scale the embodied carbon by, in seconds. If not provided,time defaults to the value of the timestep duration.',\n        unit: 'seconds',\n        'aggregation-method': {\n          time: 'copy',\n          component: 'copy',\n        },\n      },\n    },\n    outputs: {\n      'embodied-carbon': {\n        description: 'embodied carbon for a resource, scaled by usage',\n        unit: 'gCO2e',\n        'aggregation-method': {\n          time: 'sum',\n          component: 'sum',\n        },\n      },\n    },\n  },\n});\n")),(0,o.kt)("p",null,"However, there are cases where a plugin might not have parameter metadata in its source code, either because it was omitted, it was not knowable in advance, or the plugin was built before we shipped the ",(0,o.kt)("inlineCode",{parentName:"p"},"explain")," feature. Sometimes, you might want to override the hard-coded defaults and use alternative metadata. In these cases, you can define new plugin metadata in the IMP file. It is considered best-practice to ensure all plugin instances have a complete set of plugin metadata."),(0,o.kt)("p",null,"Setting parameter metadata from the IMP file is done in the plugin instance's ",(0,o.kt)("inlineCode",{parentName:"p"},"initialize")," block, as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"initialize:\n  plugins:\n    interpolate:\n      method: Interpolation\n      path: 'builtin'\n      config:\n        method: linear\n        x: [0, 10, 50, 100]\n        y: [0.12, 0.32, 0.75, 1.02]\n        input-parameter: 'cpu/utilization'\n        output-parameter: 'cpu-factor'\n      parameter-metadata:\n        inputs:\n          cpu/utilization:\n            description: 'portion of the total CPU capacity being used by an application'\n            unit: 'percentage'\n            aggregation-method:\n              time: avg\n              component: avg\n        outputs:\n          cpu-factor:\n            description: \"a dimensionless intermediate used to scale a processor's thermal design power by CPU usage\"\n            unit: 'dimensionless'\n            aggregation-method:\n              time: avg\n              component: avg\n")),(0,o.kt)("h2",{id:"example-imp"},"Example IMP"),(0,o.kt)("p",null,"The following IMP uses three plugins: ",(0,o.kt)("inlineCode",{parentName:"p"},"sci"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"sci-embodied")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"sum-carbon"),". Of these, only ",(0,o.kt)("inlineCode",{parentName:"p"},"sci-embodied"),' has defaults hardcoded into the plugin code. The other two do not because they are "generic" arithmetic plugins for whom the values cannot be known in advance. Therefore, we set new parameter metadata in the ',(0,o.kt)("inlineCode",{parentName:"p"},"initialize")," block for ",(0,o.kt)("inlineCode",{parentName:"p"},"sci")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"sum-carbon")," but use the hardcoded defaults for ",(0,o.kt)("inlineCode",{parentName:"p"},"sci-embodied"),"."),(0,o.kt)("p",null,"We toggle the ",(0,o.kt)("inlineCode",{parentName:"p"},"explainer")," feature by adding ",(0,o.kt)("inlineCode",{parentName:"p"},"explainer: true")," in the IMP context."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"name: sci\ndescription: successful path\ntags:\nexplainer: true\ninitialize:\n  plugins:\n    sci-embodied:\n      path: 'builtin'\n      method: SciEmbodied\n    'sum-carbon':\n      path: 'builtin'\n      method: Sum\n      config:\n        input-parameters:\n          - carbon-operational\n          - embodied-carbon\n        output-parameter: carbon\n      parameter-metadata:\n        inputs:\n          carbon-operational:\n            description: \"carbon emitted due to an application's execution\"\n            unit: 'gCO2eq'\n            aggregation-method:\n              time: sum\n              component: sum\n          embodied-carbon:\n            description: \"carbon emitted during the production, distribution and disposal of a hardware component, scaled by the fraction of the component's lifespan being allocated to the application under investigation\"\n            unit: 'gCO2eq'\n            aggregation-method:\n              time: sum\n              component: sum\n        outputs:\n          carbon:\n            description: \"total carbon emissions attributed to an application's usage as the sum of embodied and operational carbon\"\n            unit: 'gCO2eq'\n            aggregation-method:\n              time: sum\n              component: sum\n    sci:\n      kind: plugin\n      method: Sci\n      path: 'builtin'\n      config:\n        functional-unit: requests\n      parameter-metadata:\n        inputs:\n          carbon:\n            description: \"total carbon emissions attributed to an application's usage as the sum of embodied and operational carbon\"\n            unit: 'gCO2eq'\n            aggregation-method:\n              time: sum\n              component: sum\n          requests:\n            description: 'number of requests made to application in the given timestep'\n            unit: 'requests'\n            aggregation-method:\n              time: sum\n              component: sum\n        outputs:\n          sci:\n            description: 'software carbon intensity expressed as a rate of carbon emission per request'\n            unit: 'gCO2eq/request'\n            aggregation-method:\n              time: sum\n              component: sum\ntree:\n  children:\n    child:\n      pipeline:\n        compute:\n          - sci-embodied\n          - sum-carbon\n          - sci\n      defaults:\n        device/emissions-embodied: 1533.120 # gCO2eq\n        time-reserved: 3600 # 1hr in seconds\n        device/expected-lifespan: 94608000 # 3 years in seconds\n        vcpus-allocated: 1\n        vcpus-total: 8\n      inputs:\n        - timestamp: 2023-07-06T00:00\n          duration: 3600\n          energy: 5\n          carbon-operational: 5\n          requests: 100\n")),(0,o.kt)("p",null,"When we execute this IMP, the following ",(0,o.kt)("inlineCode",{parentName:"p"},"explain")," block is added to the output file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"explain:\n  sci-embodied:\n    inputs:\n      vCPUs:\n        description: number of CPUs allocated to an application\n        unit: CPUs\n        aggregation-method:\n          time: copy\n          component: copy\n      memory:\n        description: RAM available for a resource, in GB\n        unit: GB\n        aggregation-method:\n          time: copy\n          component: copy\n      ssd:\n        description: number of SSDs available for a resource\n        unit: SSDs\n        aggregation-method:\n          time: copy\n          component: copy\n      hdd:\n        description: number of HDDs available for a resource\n        unit: HDDs\n        aggregation-method:\n          time: copy\n          component: copy\n      gpu:\n        description: number of GPUs available for a resource\n        unit: GPUs\n        aggregation-method:\n          time: copy\n          component: copy\n      usage-ratio:\n        description: >-\n          a scaling factor that can be used to describe the ratio of actual\n          resource usage comapred to real device usage, e.g. 0.25 if you are\n          using 2 out of 8 vCPUs, 0.1 if you are responsible for 1 out of 10 GB\n          of storage, etc\n        unit: dimensionless\n        aggregation-method:\n          time: copy\n          component: copy\n      time:\n        description: >-\n          a time unit to scale the embodied carbon by, in seconds. If not\n          provided,time defaults to the value of the timestep duration.\n        unit: seconds\n        aggregation-method:\n          time: copy\n          component: copy\n    outputs:\n      embodied-carbon:\n        description: embodied carbon for a resource, scaled by usage\n        unit: gCO2eq\n        aggregation-method:\n          time: sum\n          component: sum\n  sum-carbon:\n    inputs:\n      carbon-operational:\n        unit: gCO2eq\n        description: carbon emitted due to an application's execution\n        aggregation-method:\n          time: sum\n          component: sum\n      embodied-carbon:\n        unit: gCO2eq\n        description: >-\n          carbon emitted during the production, distribution and disposal of a\n          hardware component, scaled by the fraction of the component's lifespan\n          being allocated to the application under investigation\n        aggregation-method:\n          time: sum\n          component: sum\n    outputs:\n      carbon:\n        unit: gCO2eq\n        description: >-\n          total carbon emissions attributed to an application's usage as the sum\n          of embodied and operational carbon\n        aggregation-method:\n          time: sum\n          component: sum\n  sci:\n    inputs:\n      carbon:\n        unit: gCO2eq\n        description: >-\n          total carbon emissions attributed to an application's usage as the sum\n          of embodied and operational carbon\n        aggregation-method:\n          time: sum\n          component: sum\n      functional-unit:\n        description: >-\n          the name of the functional unit in which the final SCI value should be\n          expressed, e.g. requests, users\n        unit: none\n        aggregation-method:\n          time: sum\n          component: sum\n      requests:\n        unit: requests\n        description: number of requests made to application in the given timestep\n        aggregation-method:\n          time: sum\n          component: sum\n    outputs:\n      sci:\n        unit: gCO2eq/request\n        description: >-\n          software carbon intensity expressed as a rate of carbon emission per\n          request\n        aggregation-method:\n          time: sum\n          component: sum\n")),(0,o.kt)("h2",{id:"when-not-to-use-explainer"},"When ",(0,o.kt)("em",{parentName:"h2"},"not")," to use ",(0,o.kt)("inlineCode",{parentName:"h2"},"explainer")),(0,o.kt)("p",null,"In IMPs where you are only using generic plugins, or override all the metadata loaded in from the plugin source code, ",(0,o.kt)("inlineCode",{parentName:"p"},"explainer")," will simply echo back information from your ",(0,o.kt)("inlineCode",{parentName:"p"},"initialize")," block since all the parameter metadata is set there. In these cases, the ",(0,o.kt)("inlineCode",{parentName:"p"},"explain")," block is probably redundant information as you could just read the same information in your IMP's ",(0,o.kt)("inlineCode",{parentName:"p"},"plugins")," section. The point of ",(0,o.kt)("inlineCode",{parentName:"p"},"explain")," is to confirm what units and parameters are being passed through a pipeline when you have a mixture of plugins from many sources whose parameter metadata is defined in-code and in-IMP."))}c.isMDXComponent=!0}}]);