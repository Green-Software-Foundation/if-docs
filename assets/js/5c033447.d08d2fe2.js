"use strict";(self.webpackChunkgreen_software_training=self.webpackChunkgreen_software_training||[]).push([[250],{4137:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=p(t),m=o,h=d["".concat(s,".").concat(m)]||d[m]||c[m]||i;return t?a.createElement(h,l(l({ref:n},u),{},{components:t})):a.createElement(h,l({ref:n},u))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,l=new Array(i);l[0]=d;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r.mdxType="string"==typeof e?e:o,l[1]=r;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9546:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var a=t(7462),o=(t(7294),t(4137));const i={},l="Model Plugin Configuration",r={unversionedId:"specification/model-plugin-config",id:"specification/model-plugin-config",title:"Model Plugin Configuration",description:"WARNING: this material is not fully implemented in the alpha release. It signals future upgrades on the roadmap for future releases.",source:"@site/docs/04-specification/model-plugin-config.md",sourceDirName:"04-specification",slug:"/specification/model-plugin-config",permalink:"/specification/model-plugin-config",draft:!1,editUrl:"https://github.com/Green-Software-Foundation/TODO/docs/04-specification/model-plugin-config.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Model Pipeline",permalink:"/specification/model-pipeline"},next:{title:"Model Plugin",permalink:"/specification/model-plugin"}},s={},p=[{value:"Root Config",id:"root-config",level:2},{value:"inputs",id:"inputs",level:2},{value:"Node Config",id:"node-config",level:2},{value:"Namespacing",id:"namespacing",level:2},{value:"Overriding",id:"overriding",level:2}],u={toc:p};function c(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"model-plugin-configuration"},"Model Plugin Configuration"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"WARNING"),": this material is not fully implemented in the alpha release. It signals future upgrades on the roadmap for future releases.")),(0,o.kt)("p",null,"There are several places in an Impl file where you can add configuration for a model. "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"input"),(0,o.kt)("li",{parentName:"ul"},"Node (Grouping or Component) Config"),(0,o.kt)("li",{parentName:"ul"},"Root Config")),(0,o.kt)("p",null,"There are also several function signatures to a Model Plugin. What are the rules and expectations for how we pass config to model plugins in the use and design of Model Plugins?"),(0,o.kt)("h2",{id:"root-config"},"Root Config"),(0,o.kt)("p",null,"This configuration appears in the top level of an IMPL file, under the root config node like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},".\n.\ninitialize:\n  models:\n    - name: <model-name-1>\n      kind: \n      path: <path-to-ts-module-to-load>\n      config:\n           <key>: <value>\n    - name: <model-name-2>\n      path: <path-to-ts-module-to-load>\n      config:\n           <key>: <value>          \n.\n.\ngraph: ~\n")),(0,o.kt)("p",null,"We call each model in the root model config array above the ",(0,o.kt)("inlineCode",{parentName:"p"},"configure(name: string, config: Configuration)")," function. We pass the name we are calling this model, and we pass the config as described in the root config."),(0,o.kt)("p",null,"Any configuration here should be:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Global for the entire graph."),(0,o.kt)("li",{parentName:"ul"},"Constant. It should not be used to provide default values for every node. If that's your desire, use node config at the graph's root."),(0,o.kt)("li",{parentName:"ul"},"Anything related to one-time setup, e.g., authentication information.")),(0,o.kt)("h2",{id:"inputs"},"inputs"),(0,o.kt)("p",null,"Ultimately, the inputs are passed to the model through the ",(0,o.kt)("inlineCode",{parentName:"p"},"execute(inputs: Array<input>)")," function. "),(0,o.kt)("p",null,"An essential characteristic of the Impact Framework is that the model is passed everything it needs to perform its calculation in the input nodes. All the data required to calculate an input exists in each input node. Ensuring all the required data is self-contained in an input makes building and testing models easier. "),(0,o.kt)("p",null,"As such, the most important place to put configuration that is directly related to the calculation of an input is in the input, like so: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"backend:\n  .\n  .\n  inputs: \n    - timestamp: 2023-07-06T00:00\n      duration: 5\n      cpu-util: 33\n      physical-processor: Intel Xeon Platinum 8175\n    - timestamp: 2023-07-06T00:05\n      duration: 5\n      cpu-util: 23\n      physical-processor: Intel Xeon Platinum 8175\n    - timestamp: 2023-07-06T00:10\n      duration: 5\n      cpu-util: 11\n      physical-processor: Intel Xeon Platinum 8175\n")),(0,o.kt)("p",null,"In the above example, the model requires the ",(0,o.kt)("em",{parentName:"p"},"processor")," to calculate each input. So, every input has the processor as one of its parameters."),(0,o.kt)("p",null,"Every input has all the data needed to calculate that one input. "),(0,o.kt)("h2",{id:"node-config"},"Node Config"),(0,o.kt)("p",null,"The above approach can be verbose, with the same data repeated across multiple inputs. So, to make life easier when creating an IMPL file, you can also add configuration to ",(0,o.kt)("em",{parentName:"p"},"Node Configs"),", like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"graph:\n  children:\n    backend:\n      pipeline: \n        - model-1\n      config: \n        model-1:\n          physical-processor: Intel Xeon Platinum 8175\n          thermal-design-power: 200\n      inputs: \n        - timestamp: 2023-07-06T00:00\n          duration: 5\n          cpu: 33\n")),(0,o.kt)("p",null,"In the above example, we added config related to model-1 in the component node. Effectively, the config for the model is copied into every input underneath. The reality of how this happens is more complex (see ",(0,o.kt)("a",{parentName:"p",href:"#Namespacing"},"Namespacing")," section for more info), but for brevity, we can describe the above as having this effect:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"graph:\n  children:\n    backend:\n      pipeline: \n        - model-1\n      config: \n        model-1:\n          physical-processor: Intel Xeon Platinum 8175\n          thermal-design-power: 200\n      inputs: \n        - timestamp: 2023-07-06T00:00\n          duration: 5\n          cpu: 33\n          physical-processor: Intel Xeon Platinum 8175\n          thermal-design-power: 200          \n")),(0,o.kt)("p",null,"Ultimately, the input must contain all the data required for its calculation with the model, so the config for model-1 is copied into every input. "),(0,o.kt)("h2",{id:"namespacing"},"Namespacing"),(0,o.kt)("p",null,"How do we handle the situation where there are two models, each with the same configuration params? One will overwrite the other. Models are dynamic, and most will be created outside of any governance or control of the IEF team, so we can't enforce that every config param is unique."),(0,o.kt)("p",null,"The solution is to namespace any config added into an input and ensure that inputs passed to a model only contain data in its namespace."),(0,o.kt)("p",null,"In the below example, the config for model-1 and model-2 at the component node level is added to the input (with a namespace post-pended so we know where the config came from) like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"graph:\n  children:\n    backend:\n      pipeline: \n        - model-1\n      config: \n        model-1:\n          verbose: true\n        model-1:\n          verbose: false\n      inputs: \n        - timestamp: 2023-07-06T00:00\n          duration: 5\n          cpu: 33\n          verbose::model-1: true\n          verbose::model-2: false\n")),(0,o.kt)("p",null,"Both models use a param called ",(0,o.kt)("inlineCode",{parentName:"p"},"verbose")," to signal how much data the model should export for debugging purposes, but for one it's set to true and the other false. "),(0,o.kt)("p",null,"We handle this by post-pending ",(0,o.kt)("inlineCode",{parentName:"p"},"::<name-of-model>")," to the key and adding it to the input. That way, model-1 and model-2 can have the same variable but different values."),(0,o.kt)("p",null,"But the model expects ",(0,o.kt)("inlineCode",{parentName:"p"},"verbose")," to be passed into the execute function, not ",(0,o.kt)("inlineCode",{parentName:"p"},"verbose::model-1"),"."),(0,o.kt)("p",null,"IEF ensures that for every model, it only passes in:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Data that ",(0,o.kt)("strong",{parentName:"li"},"isn't")," associated with any namespace (i.e., data that doesn't end with ",(0,o.kt)("inlineCode",{parentName:"li"},"::<namespace>"),")"),(0,o.kt)("li",{parentName:"ul"},"Data that ",(0,o.kt)("strong",{parentName:"li"},"is only")," associated with this model's namespace (i.e., data that ends with ",(0,o.kt)("inlineCode",{parentName:"li"},"::<this-models-name"),"):")),(0,o.kt)("p",null,"For the above example, model-1 would effectively see this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"inputs: \n  - timestamp: 2023-07-06T00:00\n    duration: 5\n    cpu: 33\n    verbose: true\n")),(0,o.kt)("p",null,"And model-2 would see this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"inputs: \n  - timestamp: 2023-07-06T00:00\n    duration: 5\n    cpu: 33\n    verbose: false\n")),(0,o.kt)("p",null,"This way, there are no clashes with any configuration that shares the same names between models. Each model has its own namespace."),(0,o.kt)("h2",{id:"overriding"},"Overriding"),(0,o.kt)("p",null,"You can set configuration on many levels in the graph; lower level, deeper config, overrides the same config on higher levels of the graph. In the below example, ",(0,o.kt)("inlineCode",{parentName:"p"},"verbose")," is configured in two places in the graph with different values."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"graph:\n  config:\n    model-1:\n      verbose: false\n      physical-processor: Intel Xeon Platinum 8175\nbackend:\n  pipeline: \n    - model-1\n  config: \n    model-1:\n      verbose: true\n      region: west-us\n  inputs: \n    - timestamp: 2023-07-06T00:00\n      duration: 5\n      cpu: 33\n")),(0,o.kt)("p",null,"Eventually, what gets added to the graph is something like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"graph:\n  config:\n    model-1:\n      verbose: false\n      physical-processor: Intel Xeon Platinum 8175\nbackend:\n  pipeline: \n    - model-1\n  config: \n    model-1:\n      verbose: true\n      region: west-us\n  inputs: \n    - timestamp: 2023-07-06T00:00\n      duration: 5\n      cpu: 33\n      verbose::model-1: true # set on both levels, but only the closest value taken\n      region::model-1: west-us # set just on component node\n      physical-processor::model-1: Intel Xeon Platinum 8175 # set on root node\n")),(0,o.kt)("p",null,"The verbose param is set on two levels of the graph, but the lower level config overrides the higher level config."),(0,o.kt)("p",null,"In the end, however, model-1 is passed data without the ",(0,o.kt)("inlineCode",{parentName:"p"},"::model-1")," data that's post-pended, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"inputs: \n  - timestamp: 2023-07-06T00:00\n    duration: 5\n    cpu: 33\n    verbose: true # set on both levels, but only the closest value taken\n    region: west-us # set just on component node\n    physical-processor: Intel Xeon Platinum 8175 # set on the root node\n")))}c.isMDXComponent=!0}}]);