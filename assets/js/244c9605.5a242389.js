"use strict";(self.webpackChunkgreen_software_training=self.webpackChunkgreen_software_training||[]).push([[426],{4137:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>c});var i=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=i.createContext({}),u=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=u(e.components);return i.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},d=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=u(t),c=r,g=d["".concat(s,".").concat(c)]||d[c]||m[c]||a;return t?i.createElement(g,o(o({ref:n},p),{},{components:t})):i.createElement(g,o({ref:n},p))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var u=2;u<a;u++)o[u]=t[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6869:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var i=t(7462),r=(t(7294),t(4137));const a={sidebar_position:2},o="How to make plugins production ready",l={unversionedId:"developers/how-to-refine-plugins",id:"developers/how-to-refine-plugins",title:"How to make plugins production ready",description:"Our How to build plugins guide covered the basics for how to construct an Impact Framework plugin. This guide will help you to refine your plugin to make it production-ready. These are best practice guidelines - if you intend to contribute to one of our repositories, following these guidelines will help your PR to get merged. Consistency with our norms is useful for debugging and maintaining and for making your plugin as useful as possible for other Impact Framework developers.",source:"@site/docs/developers/how-to-refine-plugins.md",sourceDirName:"developers",slug:"/developers/how-to-refine-plugins",permalink:"/developers/how-to-refine-plugins",draft:!1,editUrl:"https://github.com/Green-Software-Foundation/if-docs/edit/master/docs/developers/how-to-refine-plugins.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"How to build plugins",permalink:"/developers/how-to-build-plugins"},next:{title:"How to write unit tests",permalink:"/developers/how-to-write-unit-tests"}},s={},u=[{value:"1. Naming conventions",id:"1-naming-conventions",level:2},{value:"2. Plugin code",id:"2-plugin-code",level:2},{value:"Imports",id:"imports",level:3},{value:"Comments",id:"comments",level:3},{value:"Error handling",id:"error-handling",level:3},{value:"Validation",id:"validation",level:3},{value:"Input Validation",id:"input-validation",level:4},{value:"Config Validation",id:"config-validation",level:4},{value:"Code Modularity",id:"code-modularity",level:3},{value:"3. Unit tests",id:"3-unit-tests",level:2},{value:"4. Linting",id:"4-linting",level:2},{value:"Summary",id:"summary",level:2}],p={toc:u};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-to-make-plugins-production-ready"},"How to make plugins production ready"),(0,r.kt)("p",null,"Our ",(0,r.kt)("a",{parentName:"p",href:"/developers/how-to-build-plugins"},"How to build plugins")," guide covered the basics for how to construct an Impact Framework plugin. This guide will help you to refine your plugin to make it production-ready. These are best practice guidelines - if you intend to contribute to one of our repositories, following these guidelines will help your PR to get merged. Consistency with our norms is useful for debugging and maintaining and for making your plugin as useful as possible for other Impact Framework developers."),(0,r.kt)("h2",{id:"1-naming-conventions"},"1. Naming conventions"),(0,r.kt)("p",null,"We prefer not to use abbreviations of contractions in parameter names. Using fully descriptive names makes the code more readable, which in turn helps reviewers and anyone else aiming to understand how the plugin works. It also helps to avoid ambiguity and naming collisions within and across plugins. Your name should describe what an element does as precisely as practically possible."),(0,r.kt)("p",null,"For example, we prefer ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu/energy")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"e-cpu")," and we prefer ",(0,r.kt)("inlineCode",{parentName:"p"},"functionalUnit")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"funcUnit"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"fUnit"),", or any other abbreviation."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"In Typescript code")," we use lower Camel case (",(0,r.kt)("inlineCode",{parentName:"p"},"likeThis"),") for variable and function names and Pascal/Upper Camel case for class, type, enum, and interface names (",(0,r.kt)("inlineCode",{parentName:"p"},"LikeThis"),")."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sci")," is the name for the SCI value normalized per second."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"energy")," is the name for the array of energy metrics available to be summed in the ",(0,r.kt)("inlineCode",{parentName:"li"},"sci-e")," plugin")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"In yaml files"),", we prefer to use kebab-case (",(0,r.kt)("inlineCode",{parentName:"p"},"like-this"),") for field names. For example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"network/energy")," is the field name for the energy consumed by networking for an application"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"functional-unit")," is the unit in which to express an SCI value.")),(0,r.kt)("p",null,"Global constants can be given capitalized names, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"TIME_UNITS_IN_SECONDS"),"."),(0,r.kt)("h2",{id:"2-plugin-code"},"2. Plugin code"),(0,r.kt)("h3",{id:"imports"},"Imports"),(0,r.kt)("p",null,"We prefer the following ordering of imports in your plugin code:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Node built-in modules (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"import fs from 'fs';"),")"),(0,r.kt)("li",{parentName:"ol"},"External modules (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"import {z} from 'zod';"),")"),(0,r.kt)("li",{parentName:"ol"},"Internal modules (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"import config from 'src/config';"),")"),(0,r.kt)("li",{parentName:"ol"},"Interfaces (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"import {PluginInterface} from '@grnsft/if-core/types';"),")"),(0,r.kt)("li",{parentName:"ol"},"Types (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"import {PluginParams} from '@grnsft/if-core/types';"),")")),(0,r.kt)("h3",{id:"comments"},"Comments"),(0,r.kt)("p",null,"Each logical unit in the code should be preceded by an appropriate explanatory comment. Sometimes it is useful to include short comments inside a function that clarifies the purpose of a particular statement. Here's an example from our codebase:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Calculates the energy consumption for a single input.\n */\nconst calculateEnergy = (input: PluginParams) => {\n  const {\n    'memory/capacity': totalMemory,\n    'memory/utilization': memoryUtil,\n    'energy-per-gb': energyPerGB,\n  } = input;\n\n  // GB * kWh/GB == kWh\n  return totalMemory * (memoryUtil / 100) * energyPerGB;\n};\n")),(0,r.kt)("h3",{id:"error-handling"},"Error handling"),(0,r.kt)("p",null,"We use custom errors across our codebase to make it as easy as possible to understand the root cause of a problem.\nYou can use our error handlers by importing ",(0,r.kt)("inlineCode",{parentName:"p"},"if-core")," as a dependency of your plugin. This provides you with our error handling code and predefined list of error classes that you can invoke. This gives you tight integration with IF, because the framework can recognize those error classes and automatically incorporate them into the framework's error handling routines."),(0,r.kt)("p",null,"Just import ",(0,r.kt)("inlineCode",{parentName:"p"},"ERRORS")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"if-core")," and use the error classes that are appropriate for your use-case."),(0,r.kt)("p",null,"e.g."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {ERRORS} from '@grnsft/if-core/util';\n\nconst {MissingInputDataError} = ERRORS;\n\n...\n\nthrow new MissingInputDataError(\"my-plugin is missing my-parameter from inputs[0]\");\n")),(0,r.kt)("h3",{id:"validation"},"Validation"),(0,r.kt)("h4",{id:"input-validation"},"Input Validation"),(0,r.kt)("p",null,"We recommend using ",(0,r.kt)("inlineCode",{parentName:"p"},"inputValidation")," property from ",(0,r.kt)("inlineCode",{parentName:"p"},"PluginFactory")," for validation to ensure the integrity of input data. Validate input parameters against expected types, ranges, or constraints to prevent runtime errors and ensure data consistency."),(0,r.kt)("p",null,"You need to use ",(0,r.kt)("inlineCode",{parentName:"p"},"zod")," schema or ",(0,r.kt)("inlineCode",{parentName:"p"},"InputValidatorFunction"),". Here's an example from our codebase:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When using function with ",(0,r.kt)("inlineCode",{parentName:"li"},"InputValidatorFunction")," type.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// `inputValidation` from plugin definition\ninputValidation: (input: PluginParams, config: ConfigParams) => {\n  const inputData = {\n    'input-parameter': input[config['input-parameter']],\n  };\n  const validationSchema = z.record(z.string(), z.number());\n  validate(validationSchema, inputData);\n\n  return input;\n};\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When using ",(0,r.kt)("inlineCode",{parentName:"li"},"zod")," schema")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// `inputValidation` from plugin definition\ninputValidation: z.object({\n  duration: z.number().gt(0),\n  vCPUs: z.number().gt(0).default(1),\n  memory: z.number().gt(0).default(16),\n  ssd: z.number().gte(0).default(0),\n  hdd: z.number().gte(0).default(0),\n  gpu: z.number().gte(0).default(0),\n  'usage-ratio': z.number().gt(0).default(1),\n  time: z.number().gt(0).optional(),\n});\n")),(0,r.kt)("h4",{id:"config-validation"},"Config Validation"),(0,r.kt)("p",null,"To validate the ",(0,r.kt)("inlineCode",{parentName:"p"},"config"),", you need to use ",(0,r.kt)("inlineCode",{parentName:"p"},"configValidation")," property from ",(0,r.kt)("inlineCode",{parentName:"p"},"PluginFactory"),". Validate config parameters against expected types, ranges, or constraints to prevent runtime errors and ensure data consistency."),(0,r.kt)("p",null,"You need to use ",(0,r.kt)("inlineCode",{parentName:"p"},"zod")," schema or ",(0,r.kt)("inlineCode",{parentName:"p"},"ConfigValidatorFunction"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When using function with ",(0,r.kt)("inlineCode",{parentName:"li"},"ConfigValidatorFunction")," type.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"configValidation: (config: ConfigParams) => {\n  const configSchema = z.object({\n    coefficient: z.preprocess(\n      (value) => validateArithmeticExpression('coefficient', value, 'number'),\n      z.number()\n    ),\n    'input-parameter': z.string().min(1),\n    'output-parameter': z.string().min(1),\n  });\n\n  return validate<z.infer<typeof configSchema>>(\n    configSchema as ZodType<any>,\n    config\n  );\n};\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When using ",(0,r.kt)("inlineCode",{parentName:"li"},"zod")," schema")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"configValidation: z.object({\n  'input-parameters': z.array(z.string()),\n  'output-parameter': z.string().min(1),\n}),\n")),(0,r.kt)("h3",{id:"code-modularity"},"Code Modularity"),(0,r.kt)("p",null,"Break down complex functionality into smaller, manageable methods with well-defined responsibilities.\nEncapsulate related functionality into private methods to promote code reusability and maintainability."),(0,r.kt)("h2",{id:"3-unit-tests"},"3. Unit tests"),(0,r.kt)("p",null,"Your plugin should have unit tests with 100% coverage. We use ",(0,r.kt)("inlineCode",{parentName:"p"},"jest")," to handle unit testing. We strive to have one ",(0,r.kt)("inlineCode",{parentName:"p"},"describe")," per function. Each possible outcome from each function is separated using ",(0,r.kt)("inlineCode",{parentName:"p"},"it")," with a precise and descriptive message."),(0,r.kt)("p",null,"Here's an example that covers plugin initialization and the happy path for the ",(0,r.kt)("inlineCode",{parentName:"p"},"execute()")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { ERRORS } from '@grnsft/if-core/utils';\n\nimport { Sum } from '../../../if-run/builtins/sum';\n\nconst { InputValidationError, WrongArithmeticExpressionError } = ERRORS;\n\ndescribe('builtins/sum: ', () => {\n  describe('Sum: ', () => {\n    const config = {\n      'input-parameters': ['cpu/energy', 'network/energy', 'memory/energy'],\n      'output-parameter': 'energy',\n    };\n    const parametersMetadata = {};\n    const sum = Sum(config, parametersMetadata, {});\n\n    describe('init: ', () => {\n      it('successfully initalized.', () => {\n        expect(sum).toHaveProperty('metadata');\n        expect(sum).toHaveProperty('execute');\n      });\n    });\n\n    describe('execute(): ', () => {\n      it('successfully applies Sum strategy to given input.', async () => {\n        expect.assertions(1);\n\n        const expectedResult = [\n          {\n            duration: 3600,\n            'cpu/energy': 1,\n            'network/energy': 1,\n            'memory/energy': 1,\n            energy: 3,\n            timestamp: '2021-01-01T00:00:00Z',\n          },\n        ];\n\n        const result = await sum.execute([\n          {\n            duration: 3600,\n            'cpu/energy': 1,\n            'network/energy': 1,\n            'memory/energy': 1,\n            timestamp: '2021-01-01T00:00:00Z',\n          },\n        ]);\n\n        expect(result).toStrictEqual(expectedResult);\n      });\n    });\n  });\n});\n")),(0,r.kt)("p",null,"We have a ",(0,r.kt)("a",{parentName:"p",href:"/developers/how-to-write-unit-tests"},"dedicated page")," explaining in more detail how to write great unit tests for Impact Framework plugins."),(0,r.kt)("h2",{id:"4-linting"},"4. Linting"),(0,r.kt)("p",null,"We use ESLint to format our code. We use a very simple configuration file (",(0,r.kt)("inlineCode",{parentName:"p"},"eslintrc.json"),"), as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "extends": "./node_modules/gts/",\n  "rules": {\n    "@typescript-eslint/no-explicit-any": ["off"]\n  }\n}\n')),(0,r.kt)("p",null,"For our repositories we use Github CI to enforce the linting rules for any pull requests."),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"On this page, we have outlined best practices for refining your plugins so that they conform to our expected norms. This will help you write clean, efficient, and understandable code!"))}m.isMDXComponent=!0}}]);