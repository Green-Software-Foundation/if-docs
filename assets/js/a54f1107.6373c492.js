"use strict";(self.webpackChunkgreen_software_training=self.webpackChunkgreen_software_training||[]).push([[837],{4137:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),m=p(n),c=i,h=m["".concat(s,".").concat(c)]||m[c]||d[c]||l;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,o=new Array(l);o[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var p=2;p<l;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4140:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>p});var a=n(7462),i=(n(7294),n(4137));const l={author:"Asim Hussain (@jawache)",abstract:"How models are chained together into a pipeline in order to compute the impacts of"},o="Model Pipeline",r={unversionedId:"specification/model-pipeline",id:"specification/model-pipeline",title:"Model Pipeline",description:"Introduction",source:"@site/docs/06-specification/model-pipeline.md",sourceDirName:"06-specification",slug:"/specification/model-pipeline",permalink:"/specification/model-pipeline",draft:!1,editUrl:"https://github.com/Green-Software-Foundation/ief/docs/06-specification/model-pipeline.md",tags:[],version:"current",frontMatter:{author:"Asim Hussain (@jawache)",abstract:"How models are chained together into a pipeline in order to compute the impacts of"},sidebar:"tutorialSidebar",previous:{title:"Manifest File",permalink:"/specification/manifest-file"},next:{title:"Model Plugin Configuration",permalink:"/specification/model-plugin-config"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Initialization",id:"initialization",level:2},{value:"Usage",id:"usage",level:2},{value:"Example",id:"example",level:2},{value:"<code>instance-metadata</code>",id:"instance-metadata",level:3},{value:"<code>thermal-design-power</code>",id:"thermal-design-power",level:3},{value:"<code>teads-curve</code>",id:"teads-curve",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"Re-usability",id:"re-usability",level:3},{value:"Upgradability",id:"upgradability",level:3},{value:"Consistency",id:"consistency",level:3},{value:"Debuggability",id:"debuggability",level:3},{value:"Simulation",id:"simulation",level:3},{value:"Modelling Managed Services",id:"modelling-managed-services",level:3}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"model-pipeline"},"Model Pipeline"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"As ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Peter_H._Salus",title:"Peter H. Salus"},"Peter H. Salus")," said in his book ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Unix_philosophy#cite_note-taoup-ch1s6-1"},"A Quarter-Century of Unix")," the Unix philosophy is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Write programs that do one thing and do it well."),(0,i.kt)("li",{parentName:"ul"},"Write programs to work together."),(0,i.kt)("li",{parentName:"ul"},"Write programs to handle text streams, because that is a universal interface.")),(0,i.kt)("p",null,"Our approach to models in the ",(0,i.kt)("a",{parentName:"p",href:"/specification/impact-framework"},"Impact Engine Framework")," is the same. "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Each model will do one thing and do it well. "),(0,i.kt)("li",{parentName:"ul"},"Models work with each other. "),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("a",{parentName:"li",href:"/specification/manifest-file"},"Manifest File")," text format is the communication medium between models.")),(0,i.kt)("p",null,"Calculating a component's impacts often requires using multiple models in sequence. Each model takes as input the outputs of the previous model in the chain, all working together to calculate impacts from inputs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mermaid"},"flowchart LR\ninputs --\x3e Model1 --\x3e Model2 --\x3e Model3 --\x3e outputs\n")),(0,i.kt)("p",null,"At the start of the chain, we input source inputs. Each model in the chain takes as input the inputs and modifies them somehow before passing them along to the next model in the chain."),(0,i.kt)("p",null,"The nature of the modification is flexible and defined by the model. Some model plugins will calculate an impact metric (for example, energy from utilization) and add that to the input before passing that to the next model. Some models will enrich the input with meta-data required for other models, for example, adding grid carbon intensity values."),(0,i.kt)("h2",{id:"initialization"},"Initialization"),(0,i.kt)("p",null,"All the model plugins used in any component in the graph are configured at the top of the ",(0,i.kt)("a",{parentName:"p",href:"/specification/manifest-file"},"Manifest File")," in the initialize section. There are multiple places to add configuration for model plugins; any configuration added here is global and applied to every use of the model throughout the graph."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},".\n.\nconfig:\n  models:\n    - name: <model-name-1>\n      kind: builtin | plugin | shell\n      path: <path-to-ts-module-to-load>\n      config:\n           <key>: <value>\n    - name: <model-name-2>\n      kind: builtin | plugin | shell    \n      path: <path-to-ts-module-to-load>\n      config:\n           <key>: <value>          \n.\n.\ngraph: ~\n")),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("p",null,"In component nodes, we then configure the models we want to use in a pipeline like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"backend:\n  pipeline:\n    - model-1\n    - model-2\n    - model-3  \n  config: \n    model-1:\n      <key>: <value>\n    model-2:\n      <key>: <value>        \n    model-3:\n      <key>: <value>                \n  inputs: \n    - timestamp: 2023-07-06T00:00\n      duration: 5\n      cpu: 33\n    - timestamp: 2023-07-06T00:05\n      duration: 5\n      cpu: 23\n    - timestamp: 2023-07-06T00:10\n      duration: 5\n      cpu: 11\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"pipeline")," defines the models we apply and the order in which we use them."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"config")," in this part of the graph is config for each model in the pipeline (if any is required). Since we have multiple models, we need to define each config independently."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"inputs")," are the source inputs, the values we are pumping into the start of this pipeline.")),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("p",null,"Let's look at a simple pseudo example, to begin with a pipeline like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - instance-metadata\n  - thermal-design-power\n  - teads-curve\n")),(0,i.kt)("p",null,"Using the above, we can combine multiple smaller models together to calculate the energy consumed by this input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"inputs: \n  - timestamp: 2023-07-06T00:00\n    vendor: aws\n    instance-type: m5d.large\n    duration: 5\n    cpu-util: 33\n")),(0,i.kt)("h3",{id:"instance-metadata"},(0,i.kt)("inlineCode",{parentName:"h3"},"instance-metadata")),(0,i.kt)("p",null,"This model plugin takes as input an ",(0,i.kt)("em",{parentName:"p"},"instance type")," and outputs the name of the physical processor of the underlying architecture as well as other valuable metadata, like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"inputs: \n  - timestamp: 2023-07-06T00:00\n    vendor: aws\n    instance-type: m5d.large\n    duration: 5\n    cpu-util: 33\n")),(0,i.kt)("p",null,"to "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"inputs: \n  - timestamp: 2023-07-06T00:00\n    vendor: aws\n    instance-type: m5d.large\n    duration: 5\n    cpu-util: 33\n    physical-processor: Intel Xeon Platinum 8175 # <-- output\n    used-cores: 1 # <-- output\n    total-cores: 26 # <-- output     \n")),(0,i.kt)("h3",{id:"thermal-design-power"},(0,i.kt)("inlineCode",{parentName:"h3"},"thermal-design-power")),(0,i.kt)("p",null,"Takes as input details about a physical processor, does a lookup against a ",(0,i.kt)("a",{parentName:"p",href:"https://www.intel.com/content/www/us/en/products/sku/120506/intel-xeon-platinum-8170-processor-35-75m-cache-2-10-ghz/specifications.html"},"database")," to obtain the thermal-design-power value (a measure of max power consumption), like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"inputs: \n  - timestamp: 2023-07-06T00:00\n    vendor: aws\n    instance-type: m5d.large\n    duration: 5\n    cpu-util: 33\n    physical-processor: Intel Xeon Platinum 8175 # <-- input\n    used-cores: 1\n    total-cores: 26\n")),(0,i.kt)("p",null,"to"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"inputs: \n  - timestamp: 2023-07-06T00:00\n    vendor: aws\n    instance-type: m5d.large\n    duration: 5\n    cpu: 33\n    physical-processor: Intel Xeon Platinum 8175\n    used-cores: 1\n    total-cores: 26\n    thermal-design-power: 165 # <-- output\n")),(0,i.kt)("h3",{id:"teads-curve"},(0,i.kt)("inlineCode",{parentName:"h3"},"teads-curve")),(0,i.kt)("p",null,"TEADs is a now very well-known set of ",(0,i.kt)("a",{parentName:"p",href:"https://medium.com/teads-engineering/building-an-aws-ec2-carbon-emissions-dataset-3f0fd76c98ac"},"generalized power curve coefficients"),". Given a few inputs in can estimate the energy consumed for a given utilization. The coefficients are here for reference:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"util"),(0,i.kt)("th",{parentName:"tr",align:null},"coeff"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Idle"),(0,i.kt)("td",{parentName:"tr",align:null},"0.12")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"10"),(0,i.kt)("td",{parentName:"tr",align:null},"0.32")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"50"),(0,i.kt)("td",{parentName:"tr",align:null},"0.75")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"100"),(0,i.kt)("td",{parentName:"tr",align:null},"1.02")))),(0,i.kt)("p",null,"So if the thermal-design-power is 100W and the utilization is 50%, then according to the TEADs curve, the power would be 0.75 * 100 = 75W. The curve is generalized, so it is of limited usefulness in deciding which arch is better. Still, it is generalized enough to be used in many contexts where the data is limited."),(0,i.kt)("p",null,"Using a ",(0,i.kt)("inlineCode",{parentName:"p"},"teads-curve")," model, we'd be able to estimate energy like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"inputs: \n  - timestamp: 2023-07-06T00:00\n    vendor: aws\n    instance-type: m5d.large\n    duration: 5 # <-- input\n    cpu-util: 33 # <-- input\n    physical-processor: Intel Xeon Platinum 8175\n    used-cores: 1 # <-- input\n    total-cores: 26 # <-- input\n    thermal-design-power: 165 # <-- input\n")),(0,i.kt)("p",null,"to"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"inputs: \n  - timestamp: 2023-07-06T00:00\n    vendor: aws\n    instance-type: m5d.large\n    duration: 5\n    cpu-util: 33\n    physical-processor: Intel Xeon Platinum 8175\n    used-cores: 1\n    total-cores: 26\n    thermal-design-power: 165 \n    energy: 0.004 # <-- output\n")),(0,i.kt)("p",null,"The energy used by this instance for 5s at 33% utilization is about 0.004 Wh."),(0,i.kt)("h2",{id:"use-cases"},"Use Cases"),(0,i.kt)("p",null,"There are many advantages of composing a model pipeline from lots of smaller model plugins."),(0,i.kt)("h3",{id:"re-usability"},"Re-usability"),(0,i.kt)("p",null,"Why implement some functionality in your model plugin if another is available that already implements the functionality you need, is widespread, and is well-supported? "),(0,i.kt)("p",null,"For example, several existing models (Boavizta, Cloud Carbon Footprint, and Climatiq, to name a few) all implement the same functionality to map cloud instance types, like ",(0,i.kt)("inlineCode",{parentName:"p"},"m5d.large"),", to physical processors like ",(0,i.kt)("inlineCode",{parentName:"p"},"Intel Xeon Platinum 8175"),". Internally, they are all doing the same thing, looking up what ",(0,i.kt)("inlineCode",{parentName:"p"},"m5d.large")," is and what CPU microarchitecture it's linked to. However, the methodology they each use, the accuracy and recency of the data in the lookup tables, and how they fallback when no data is available differs"),(0,i.kt)("p",null,"If a single model plugin existed, and all it did was map cloud instance types to microarchitectures and did that one job very well. Then other models may choose to rely on that one as a pre-requisite instead of implementing the functionality themselves:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"pipeline:\n  - instance-metadata\n  - ccf\n")),(0,i.kt)("admonition",{title:"Ecosystem of plugins",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The model plugins are the bulk of functionality for the Impact Framework. A small set of tightly focused model plugins can be combined in multiple ways to meet many use cases.")),(0,i.kt)("h3",{id:"upgradability"},"Upgradability"),(0,i.kt)("p",null,"Any time you upgrade one model plugin, every other plugin that depends on it can take advantage of those changes."),(0,i.kt)("p",null,"Sticking to the above example of the ",(0,i.kt)("inlineCode",{parentName:"p"},"instance-metadata")," plugin. A new version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"instance-metadata")," plugin can be released if a cloud vendor updates its instance types or offerings. If you update your install, every plugin that depends on that data can take advantage of the update."),(0,i.kt)("h3",{id:"consistency"},"Consistency"),(0,i.kt)("p",null,"Again, sticking to the  ",(0,i.kt)("inlineCode",{parentName:"p"},"instance-metadata")," plugin example. Breaking out functionality into lots of smaller plugins allows for more consistency. This is especially true regarding plugins that do lookups against data. "),(0,i.kt)("p",null,"Rather than each plugin determining its own meta-data, one plugin can provide the metadata required for several subsequent plugins. From the data it exports to the inputs, we can see what data every subsequent plugin is using."),(0,i.kt)("h3",{id:"debuggability"},"Debuggability"),(0,i.kt)("p",null,"Since each model outputs a copy of its inputs, we can easily debug a calculation through its chain by dumping out the intermediate inputs."),(0,i.kt)("h3",{id:"simulation"},"Simulation"),(0,i.kt)("p",null,"You can create models that ",(0,i.kt)("strong",{parentName:"p"},"simulate")," making changes to the system. For example, you could create a model called ",(0,i.kt)("inlineCode",{parentName:"p"},"change-instance-type"),", which adjusts the data being passed through to ",(0,i.kt)("strong",{parentName:"p"},"simulate")," as if it was run on another cloud instance."),(0,i.kt)("p",null,"Through a set of simulation plugins, you can investigate ",(0,i.kt)("strong",{parentName:"p"},"what if scenarios"),", see the impact of work before investing any time, like so"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"component:\n  pipeline:\n    - change-instance-type \n    - instance-metadata\n    - thermal-design-power\n    - teads  \n  config: \n    change-instance-type:\n      to-instance: m5d.xlarge            \n  inputs: \n    - timestamp: 2023-07-06T00:00\n      duration: 5\n      cpu: 33\n      vendor: aws\n      instance_type: m5d.large\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"change-instance-type")," model would convert the above to this: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"component:\n  pipeline:\n    - change-instance-type \n    - instance-metadata\n    - thermal-design-power\n    - teads  \n  config: \n    change-instance-type:\n      to-instance: m5d.xlarge            \n  inputs: \n    - timestamp: 2023-07-06T00:00\n      duration: 5\n      cpu: 17.5 # <-- updated\n      vendor: aws\n      instance_type: m5d.xlarge # <-- updated\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"m5d.xlarge")," is the same CPU but twice the size of ",(0,i.kt)("inlineCode",{parentName:"p"},"m5d.large"),", so this plugin halves the utilization to mirror what might be on the new instance type."),(0,i.kt)("p",null,"The rest of the pipeline would then be the same. No other plugin would need to be changed; they would all function as before. "),(0,i.kt)("h3",{id:"modelling-managed-services"},"Modelling Managed Services"),(0,i.kt)("p",null,"We need to be able to measure the energy consumed by a processor since ",(0,i.kt)("em",{parentName:"p"},"eventually")," everything is executed on a processor. However, these days most services are consumed through higher-level managed services (for example, AWS Lambda). In these managed services, you are abstracted away from the underlying processor, utilization, and instances. How do we measure the impacts of these managed services?"),(0,i.kt)("p",null,"We first have to start with inputs. If we take AWS Lambda (or any FaaS), then the inputs we might receive are along the time/space dimension, like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"inputs: \n  - timestamp: 2023-07-06T00:00\n    duration: 5\n    gb-s: 1005\n")),(0,i.kt)("p",null,"Most cloud FaaS measure by gigabyte seconds. So, the number of seconds your function runs for multiplied by the GB of memory it used in the same period. You don't know the underlying instance or the utilization."),(0,i.kt)("p",null,"There are no models ",(0,i.kt)("em",{parentName:"p"},"currently")," that translate GB-s to energy and embodied carbon. However, by chaining several models together into a pipeline, we can ",(0,i.kt)("em",{parentName:"p"},"translate")," GB-s to some equivalent utilization on an instance type and then compute using a similar pipeline to what we've used before."),(0,i.kt)("p",null,"Imagine we had an adaptor model called ",(0,i.kt)("inlineCode",{parentName:"p"},"aws-lambda-to-instance"),", which transformed ",(0,i.kt)("inlineCode",{parentName:"p"},"gb-s")," into an input that can be computed using an existing set of models, like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"component:\n  pipeline:\n    - aws-lambda-to-instance \n    - instance-metadata\n    - thermal-design-power\n    - teads       \n  inputs: \n    - timestamp: 2023-07-06T00:00\n      duration: 5\n      gb-s: 1005\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"aws-lambda-to-instance"),"  might first transform the input to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"component:\n  pipeline:\n    - aws-lambda-to-instance \n    - instance-metadata\n    - thermal-design-power\n    - teads      \n  inputs: \n    - timestamp: 2023-07-06T00:00\n      duration: 5\n      gb-s: 1005\n      vendor: aws # <-- new\n      instance_type: m5d.large  # <-- new\n      cpu: 33   # <-- new\n")),(0,i.kt)("p",null,"The input is now in a format that can be computed using the rest of the pipeline."),(0,i.kt)("p",null,"Using ",(0,i.kt)("strong",{parentName:"p"},"Managed Services Adaptor Models")," (MSAM), we can quickly model higher-level managed services."),(0,i.kt)("p",null,"Another future is one where a model is created that directly translates ",(0,i.kt)("inlineCode",{parentName:"p"},"gb-s")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"energy"),", perhaps maintained and released by AWS themselves, like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"component:\n  pipeline:\n    - aws-lambda\n  inputs: \n    - timestamp: 2023-07-06T00:00\n      duration: 5\n      gb-s: 1005\n")),(0,i.kt)("p",null,"But with model pipelines we don't need to wait and in the meantime can fill in the gaps with adapter models,"))}d.isMDXComponent=!0}}]);